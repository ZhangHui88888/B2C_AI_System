# 安全性说明文档

> 本文档详细说明系统的安全设计、数据隔离策略和安全验证方法

---

## 多品牌数据隔离

### 核心原则

**所有数据必须按 `brand_id` 隔离，确保品牌 A 无法访问品牌 B 的任何数据。**

### 隔离机制

#### 1. 品牌识别中间件

**位置：** `worker/src/middleware/brand.ts`

**工作流程：**
```
1. 从请求 Host 头获取域名
2. 查询 brands.domain 获取 brand_id
3. 将 brand_id 注入请求头 (x-brand-id)
4. 所有后续 API 自动携带 brand_id
```

**安全要点：**
- ✅ 品牌 ID 由服务端根据域名查询，不信任前端传入
- ✅ 生产环境未匹配域名返回 404，避免误落到默认品牌
- ✅ KV 缓存键包含域名 (`brand:domain:{host}`)，避免跨品牌缓存污染

#### 2. 数据库 RLS 策略

**位置：** `docs/database/002_rls_policies.sql`

**RLS（Row Level Security）策略：**
- 所有表启用 RLS
- 每个表的 SELECT/INSERT/UPDATE/DELETE 策略都包含 `brand_id` 过滤
- 即使 SQL 注入也无法跨品牌访问数据

**示例策略：**
```sql
-- products 表 RLS 策略
CREATE POLICY "Users can only access their brand's products"
ON products
FOR ALL
USING (brand_id = current_setting('app.current_brand_id')::uuid);
```

#### 3. API 层过滤

**所有 API 查询都必须包含 `brand_id` 过滤：**

```typescript
// ✅ 正确：包含 brand_id 过滤
const { data } = await supabase
  .from('products')
  .select('*')
  .eq('brand_id', brandId);

// ❌ 错误：缺少 brand_id 过滤
const { data } = await supabase
  .from('products')
  .select('*');
```

---

## 安全验证清单

### 多品牌数据隔离验证

#### 测试场景 1：品牌数据隔离

**步骤：**
1. 创建两个测试品牌（brand-a、brand-b）
2. 为每个品牌创建测试数据（产品、订单等）
3. 使用 brand-a 域名访问，验证只能看到 brand-a 数据
4. 使用 brand-b 域名访问，验证只能看到 brand-b 数据

**验证点：**
- [ ] 产品列表只显示当前品牌产品
- [ ] 订单列表只显示当前品牌订单
- [ ] 分类列表只显示当前品牌分类
- [ ] 知识库只检索当前品牌知识
- [ ] AI 客服只使用当前品牌配置

#### 测试场景 2：API 直接调用防护

**步骤：**
1. 使用 brand-a 域名获取 API token
2. 尝试通过 API 直接传入 brand-b 的 ID
3. 验证请求被拒绝

**验证点：**
- [ ] 无法通过修改请求参数访问其他品牌数据
- [ ] 返回 403 Forbidden 或 404 Not Found
- [ ] 日志记录异常访问尝试

#### 测试场景 3：KV 缓存隔离

**步骤：**
1. 使用 brand-a 域名访问，触发 KV 缓存
2. 使用 brand-b 域名访问
3. 验证不会读取到 brand-a 的缓存

**验证点：**
- [ ] KV 缓存键包含域名：`brand:domain:brand-a.com`
- [ ] 不同域名使用不同缓存键
- [ ] 缓存数据不会跨品牌污染

#### 测试场景 4：RLS 策略验证

**步骤：**
1. 使用 Supabase SQL Editor 直接查询
2. 尝试跨品牌查询数据
3. 验证 RLS 策略生效

**验证点：**
- [ ] 直接 SQL 查询也受 RLS 限制
- [ ] 无法通过 SQL 注入绕过品牌隔离
- [ ] Service Role Key 可以绕过 RLS（仅服务端使用）

---

## 认证与授权

### Supabase Auth

**认证方式：**
- 邮箱 + 密码登录
- Session 管理
- JWT Token

**安全要点：**
- ✅ 密码使用 bcrypt 加密存储
- ✅ Session 自动过期（默认 1 小时）
- ✅ JWT Token 签名验证
- ✅ 支持刷新 Token

### 权限模型（RBAC）

**角色定义：**

| 角色 | 权限范围 | 说明 |
|------|----------|------|
| `super_admin` | 所有品牌 | 超级管理员，可切换品牌 |
| `brand_admin` | 单个品牌 | 品牌管理员，完全管理权限 |
| `editor` | 单个品牌 | 编辑，内容编辑权限 |
| `read_only` | 单个品牌 | 只读，仅查看权限 |

**权限检查：**
```typescript
// 检查用户是否有权限访问某个品牌
async function checkBrandAccess(userId: string, brandId: string): Promise<boolean> {
  const { data } = await supabase
    .from('admin_users')
    .select('role, brand_id')
    .eq('user_id', userId)
    .single();
  
  // super_admin 可以访问所有品牌
  if (data.role === 'super_admin') return true;
  
  // 其他角色只能访问自己的品牌
  return data.brand_id === brandId;
}
```

**安全要点：**
- ✅ 前端 UI 隐藏 + 后端 API 验证（双重保护）
- ✅ 与 RLS 策略对齐，避免仅前端隐藏导致越权
- ✅ 所有管理后台 API 都需要验证权限

---

## 支付安全

### Stripe 集成

**安全措施：**

#### 1. 金额/币种服务端校验

```typescript
// ❌ 错误：信任前端传入的金额
async function createOrder(items: any[], amount: number) {
  // 直接使用前端传入的 amount 创建支付
}

// ✅ 正确：服务端重新计算金额
async function createOrder(items: any[]) {
  // 1. 验证产品存在且上架
  // 2. 服务端重新计算金额
  const amount = items.reduce((sum, item) => {
    const product = await getProduct(item.product_id);
    return sum + product.price * item.quantity;
  }, 0);
  
  // 3. 创建支付
  const paymentIntent = await stripe.paymentIntents.create({
    amount: amount * 100, // 转换为分
    currency: 'usd',
  });
}
```

**验证点：**
- [ ] 订单金额由服务端计算，不信任前端
- [ ] 币种由服务端设置，不信任前端
- [ ] 产品价格从数据库读取，不信任前端

#### 2. Webhook 签名验证

```typescript
// 验证 Stripe Webhook 签名
const sig = request.headers.get('stripe-signature');
const event = stripe.webhooks.constructEvent(
  body,
  sig,
  env.STRIPE_WEBHOOK_SECRET
);
```

**验证点：**
- [ ] 所有 Webhook 请求都验证签名
- [ ] 签名验证失败返回 400
- [ ] 使用正确的 Webhook Secret

#### 3. 幂等性处理

```typescript
// 使用 stripe_event_id 去重
async function ensureStripeEventRecord(supabase: any, eventId: string) {
  const { data } = await supabase
    .from('stripe_events')
    .select('id')
    .eq('event_id', eventId)
    .single();
  
  if (data) {
    // 事件已处理，直接返回
    return { exists: true };
  }
  
  // 记录新事件
  await supabase
    .from('stripe_events')
    .insert({ event_id: eventId });
  
  return { exists: false };
}
```

**验证点：**
- [ ] 重复的 Webhook 事件不会重复处理
- [ ] 使用数据库级别的唯一约束
- [ ] 支持安全重放（重复事件返回成功）

#### 4. 订单状态机校验

```typescript
// 只允许合法的状态流转
const allowedTransitions = {
  'pending': ['paid', 'failed', 'cancelled'],
  'paid': ['processing', 'cancelled'],
  'processing': ['shipped', 'cancelled'],
  'shipped': ['delivered', 'returned'],
  'delivered': ['returned'],
};

function validateStatusTransition(from: string, to: string): boolean {
  return allowedTransitions[from]?.includes(to) || false;
}
```

**验证点：**
- [ ] 订单状态只能按规则流转
- [ ] 不允许异常回退（如 delivered → pending）
- [ ] 状态变更记录时间线

---

## 敏感数据保护

### 密钥管理

**存储位置：**
- ✅ 生产环境：Cloudflare Secrets
- ✅ 开发环境：`.dev.vars` 文件（不提交到 Git）
- ❌ 禁止：硬编码在代码中

**密钥类型：**

| 密钥 | 可见性 | 存储方式 |
|------|--------|----------|
| `SUPABASE_SERVICE_KEY` | 仅服务端 | Cloudflare Secret |
| `STRIPE_SECRET_KEY` | 仅服务端 | Cloudflare Secret |
| `DEEPSEEK_API_KEY` | 仅服务端 | Cloudflare Secret |
| `PUBLIC_SUPABASE_ANON_KEY` | 前端可见 | 环境变量 |
| `PUBLIC_STRIPE_PUBLISHABLE_KEY` | 前端可见 | 环境变量 |

### 个人信息保护（GDPR/CCPA）

**收集的个人信息：**
- 姓名、邮箱、电话
- 收货地址
- 订单历史
- 对话记录

**保护措施：**
- ✅ 数据加密传输（HTTPS）
- ✅ 数据库访问控制（RLS）
- ✅ 最小化收集原则
- ✅ 用户可删除账户和数据
- ✅ 隐私政策明确说明数据使用

**合规要点：**
- [ ] 提供隐私政策页面
- [ ] 用户同意收集数据
- [ ] 支持用户导出数据
- [ ] 支持用户删除数据
- [ ] 数据泄露通知机制

---

## API 安全

### CORS 配置

```typescript
// 只允许特定域名访问
const allowedOrigins = [
  'https://your-domain.com',
  'https://brand-a.com',
  'https://brand-b.com',
];

function cors(origin: string): Response {
  if (!allowedOrigins.includes(origin)) {
    return new Response('Forbidden', { status: 403 });
  }
  
  return new Response(null, {
    headers: {
      'Access-Control-Allow-Origin': origin,
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE',
      'Access-Control-Allow-Headers': 'Content-Type',
    },
  });
}
```

**验证点：**
- [ ] 生产环境限制 CORS 域名
- [ ] 开发环境允许 localhost
- [ ] 不使用 `*` 通配符

### 速率限制

**建议配置：**
- 登录接口：5 次/分钟
- 支付接口：10 次/分钟
- AI 对话：20 次/分钟
- 普通 API：100 次/分钟

**实现方式：**
- Cloudflare Rate Limiting
- 或使用 KV 存储请求计数

### 输入验证

**所有用户输入都必须验证：**

```typescript
// ✅ 正确：验证输入
function createProduct(data: any) {
  // 验证必填字段
  if (!data.name || !data.price) {
    throw new Error('Missing required fields');
  }
  
  // 验证数据类型
  if (typeof data.price !== 'number' || data.price <= 0) {
    throw new Error('Invalid price');
  }
  
  // 验证长度
  if (data.name.length > 200) {
    throw new Error('Name too long');
  }
  
  // 清理 HTML（防止 XSS）
  data.description = sanitizeHtml(data.description);
}
```

**验证点：**
- [ ] 验证数据类型
- [ ] 验证数据范围
- [ ] 验证字符串长度
- [ ] 清理 HTML 输入（防止 XSS）
- [ ] 参数化查询（防止 SQL 注入）

---

## 日志与监控

### 关键路径日志

**必须记录的事件：**
- 订单创建/支付/发货
- Stripe Webhook 回调
- AI 对话（用户消息 + AI 回复）
- 登录/登出
- 权限变更
- 数据导出

**日志格式：**
```typescript
{
  timestamp: '2025-12-25T09:00:00Z',
  level: 'info',
  event: 'order_created',
  request_id: 'req_123',
  brand_id: 'brand_abc',
  order_id: 'order_456',
  user_id: 'user_789',
  amount: 99.99,
  currency: 'usd',
}
```

**验证点：**
- [ ] 关键事件都有日志
- [ ] 日志包含 request_id、brand_id、order_id 等关键字段
- [ ] 敏感信息（密码、密钥）不记录到日志

### 异常告警

**需要告警的事件：**
- 订单创建失败
- Stripe Webhook 失败/超时
- 支付回调处理失败
- AI API 调用失败
- 数据库连接失败
- 错误率超过阈值（如 5%）

**告警方式：**
- 邮件通知
- Slack 通知
- 短信通知（紧急情况）

---

## 安全检查清单

### 开发阶段

- [ ] 所有 API 都包含 `brand_id` 过滤
- [ ] 所有表都启用 RLS 策略
- [ ] 敏感密钥使用 Secrets 管理
- [ ] 订单金额由服务端计算
- [ ] Webhook 签名验证
- [ ] 输入验证和清理
- [ ] 错误信息不泄露敏感信息

### 测试阶段

- [ ] 多品牌数据隔离测试
- [ ] API 越权访问测试
- [ ] KV 缓存隔离测试
- [ ] RLS 策略验证
- [ ] 支付流程安全测试
- [ ] Webhook 幂等性测试
- [ ] 订单状态机测试

### 部署阶段

- [ ] 所有 Secrets 已配置
- [ ] CORS 域名限制已配置
- [ ] HTTPS 已启用
- [ ] Stripe Webhook 已配置
- [ ] 日志和监控已启用
- [ ] 告警已配置
- [ ] 备份策略已设置

### 运维阶段

- [ ] 定期审查日志
- [ ] 定期轮换密钥
- [ ] 定期安全扫描
- [ ] 定期备份验证
- [ ] 定期更新依赖
- [ ] 定期安全培训

---

## 安全事件响应

### 数据泄露

**响应步骤：**
1. 立即隔离受影响系统
2. 评估泄露范围
3. 通知受影响用户（72 小时内）
4. 修复漏洞
5. 加强监控
6. 事后复盘

### 未授权访问

**响应步骤：**
1. 立即撤销相关权限
2. 审查访问日志
3. 评估数据影响
4. 修改所有密钥
5. 加强访问控制
6. 事后复盘

### DDoS 攻击

**响应步骤：**
1. 启用 Cloudflare DDoS 防护
2. 限制请求速率
3. 封禁恶意 IP
4. 监控服务状态
5. 通知用户（如需要）

---

## 最佳实践

### 开发

1. **永远不要信任前端输入**
   - 所有数据都在服务端验证
   - 金额、价格、数量都由服务端计算

2. **最小权限原则**
   - 前端使用 Anon Key（受 RLS 限制）
   - 服务端使用 Service Role Key（仅必要时）

3. **防御性编程**
   - 假设所有输入都是恶意的
   - 使用参数化查询
   - 清理 HTML 输入

### 部署

1. **环境隔离**
   - 测试环境和生产环境使用不同密钥
   - 测试环境使用 Stripe 测试模式

2. **密钥管理**
   - 使用 Cloudflare Secrets
   - 定期轮换密钥
   - 不提交密钥到 Git

3. **监控告警**
   - 关键路径都有日志
   - 异常情况都有告警
   - 定期审查日志

---

## 更新日志

- 2025-12-25：初始版本